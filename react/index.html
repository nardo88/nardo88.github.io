<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Resct documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="css/style.css">
</head>
<body>
	<div class="header">
		<div class="burger">
			<button class="burger_button"><span class="burger_item"></span></button>
			
		</div>
		<div class="icon">
			<svg class="icon" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve">
				<path style="fill:#E1E1E1;" d="M512,256c0,84.344-40.793,159.159-103.717,205.803c-26.342,19.519-56.56,34.105-89.287,42.381
				C298.841,509.294,277.744,512,256,512s-42.851-2.706-63.007-7.816c-32.726-8.276-62.945-22.862-89.287-42.392
				C40.782,415.148,0,340.334,0,256C0,114.615,114.615,0,256,0S512,114.615,512,256z"/>
				<g>
				<path style="fill:#5ADAFD;" d="M408.545,400.144c-1.202-8.056-2.79-16.353-4.754-24.837c-1.735-7.45-3.751-15.047-6.039-22.758
				c-6.019-20.25-13.949-41.294-23.562-62.568c-4.211-9.3-8.746-18.641-13.584-27.972c-4.263-8.223-8.756-16.457-13.49-24.639
				c-4.723-8.192-9.592-16.196-14.597-24.001c-5.653-8.85-11.473-17.439-17.429-25.736c-13.605-18.965-27.867-36.362-42.402-51.702
				c-5.527-5.841-11.097-11.379-16.687-16.593c-6.363-5.956-12.758-11.483-19.143-16.551c-41.681-33.092-78.994-43.029-105.085-27.972
				c-26.091,15.067-36.143,52.349-28.327,105.002c1.191,8.056,2.79,16.353,4.765,24.837c1.714,7.45,3.73,15.047,6.029,22.758
				c6.019,20.25,13.949,41.305,23.573,62.568c4.201,9.3,8.735,18.63,13.573,27.961c4.263,8.234,8.767,16.457,13.49,24.649
				c4.723,8.192,9.592,16.196,14.597,24.001c5.663,8.861,11.483,17.45,17.429,25.746c13.605,18.965,27.867,36.352,42.402,51.691
				c5.528,5.841,11.107,11.389,16.697,16.603c6.363,5.956,12.758,11.473,19.132,16.541c15.329,12.173,30.062,21.211,43.865,27.011
				c32.726-8.276,62.945-22.862,89.286-42.381C411.961,444.855,412.097,424.093,408.545,400.144z M385.076,458
				c-3.041,13.145-8.631,22.152-16.624,26.76c-7.983,4.618-18.578,4.953-31.483,1.024c-13.981-4.274-30.302-13.615-47.208-27.042
				c-5.684-4.514-11.379-9.425-17.074-14.702c-5.58-5.183-11.16-10.721-16.697-16.583c-9.509-10.062-18.913-21.076-28.087-32.893
				c-6.123-7.889-12.152-16.133-18.035-24.691c-8.537-12.403-16.781-25.464-24.618-39.048c-7.847-13.584-15.036-27.251-21.504-40.845
				c-4.472-9.373-8.6-18.714-12.361-27.961c-5.653-13.855-10.491-27.512-14.451-40.772c-2.299-7.732-4.315-15.318-5.998-22.747
				c-1.735-7.565-3.145-14.963-4.211-22.141c-3.176-21.347-3.103-40.155,0.188-54.397c3.041-13.145,8.641-22.152,16.624-26.76
				c4.315-2.487,9.383-3.741,15.161-3.741c4.932,0,10.386,0.909,16.321,2.727c13.981,4.263,30.302,13.615,47.208,27.032
				c5.684,4.514,11.389,9.425,17.074,14.723c5.59,5.172,11.16,10.71,16.687,16.562c9.519,10.062,18.923,21.076,28.108,32.904
				c6.123,7.889,12.152,16.133,18.035,24.691c8.526,12.403,16.771,25.464,24.607,39.037c7.847,13.584,15.036,27.251,21.504,40.845
				c4.472,9.383,8.6,18.725,12.361,27.972c5.653,13.855,10.491,27.502,14.451,40.761c2.299,7.732,4.315,15.318,6.008,22.747
				c1.724,7.565,3.135,14.963,4.201,22.141C388.441,424.95,388.368,443.758,385.076,458z"/>
				<path style="fill:#5ADAFD;" d="M427.677,212.961c-7.576-2.988-15.559-5.757-23.897-8.307c-7.314-2.226-14.9-4.284-22.727-6.154
				c-20.543-4.911-42.736-8.568-65.964-10.867c-10.146-1.014-20.501-1.755-30.992-2.226c-9.258-0.428-18.641-0.648-28.097-0.648
				s-18.84,0.219-28.108,0.648c-10.501,0.47-20.856,1.223-31.002,2.226c-23.228,2.299-45.411,5.956-65.954,10.867
				c-7.826,1.87-15.412,3.929-22.727,6.154c-8.338,2.539-16.321,5.319-23.897,8.307C34.816,232.5,7.544,259.856,7.544,289.98
				c0,30.124,27.272,57.48,76.769,77.03c7.576,2.988,15.548,5.757,23.886,8.307c7.314,2.226,14.9,4.284,22.727,6.144
				c20.543,4.921,42.736,8.568,65.975,10.877c10.146,1.003,20.501,1.745,31.002,2.226c9.258,0.428,18.641,0.637,28.097,0.637
				c9.456,0,18.829-0.209,28.087-0.637c10.501-0.481,20.846-1.223,31.002-2.226c23.228-2.299,45.432-5.956,65.975-10.877
				c7.826-1.87,15.412-3.918,22.727-6.154c8.328-2.539,16.311-5.308,23.886-8.297c49.507-19.55,76.769-46.905,76.769-77.03
				C504.445,259.856,477.184,232.5,427.677,212.961z M466.045,317.753c-10.679,9.979-26.937,19.435-47.01,27.366
				c-6.76,2.664-13.866,5.151-21.285,7.429c-7.283,2.247-14.858,4.305-22.695,6.165c-13.469,3.208-27.711,5.841-42.538,7.879
				c-9.885,1.369-20.031,2.466-30.386,3.271c-15.015,1.202-30.448,1.808-46.132,1.808s-31.117-0.606-46.132-1.797
				c-10.355-0.815-20.511-1.912-30.396-3.281c-14.827-2.038-29.069-4.671-42.538-7.879c-7.837-1.86-15.412-3.918-22.695-6.165
				c-7.419-2.278-14.524-4.765-21.285-7.429c-20.072-7.931-36.331-17.387-47.01-27.366c-9.864-9.206-14.869-18.547-14.869-27.773
				c0-9.226,5.005-18.568,14.869-27.773c10.679-9.979,26.937-19.435,47.01-27.366c6.76-2.664,13.866-5.151,21.285-7.429
				c7.283-2.247,14.858-4.305,22.695-6.165c13.469-3.208,27.711-5.841,42.538-7.879c9.885-1.369,20.041-2.466,30.396-3.281
				c15.015-1.191,30.448-1.797,46.132-1.797s31.117,0.606,46.132,1.808c10.355,0.805,20.501,1.902,30.386,3.271
				c14.827,2.038,29.069,4.671,42.538,7.879c7.837,1.86,15.412,3.918,22.695,6.165c7.419,2.278,14.524,4.765,21.285,7.429
				c20.072,7.931,36.331,17.387,47.01,27.366c9.864,9.206,14.869,18.547,14.869,27.773
				C480.914,299.207,475.909,308.548,466.045,317.753z"/>
				<path style="fill:#5ADAFD;" d="M380.217,74.815c-26.091-15.057-63.404-5.12-105.085,27.972
				c-6.374,5.068-12.769,10.595-19.132,16.551c-5.59,5.214-11.17,10.762-16.697,16.603c-14.535,15.339-28.797,32.726-42.412,51.691
				c-5.945,8.296-11.766,16.886-17.418,25.736c-5.005,7.805-9.874,15.809-14.597,24.001c-4.723,8.192-9.226,16.415-13.49,24.649
				c-4.838,9.331-9.373,18.672-13.573,27.961c-9.624,21.274-17.554,42.318-23.573,62.568c-2.299,7.722-4.315,15.318-6.04,22.768
				c-1.964,8.485-3.563,16.771-4.754,24.827c-3.553,23.939-3.417,44.701,0.261,61.649c26.342,19.529,56.56,34.116,89.287,42.392
				c13.803-5.799,28.536-14.838,43.865-27.011c6.384-5.068,12.779-10.595,19.143-16.541c5.59-5.214,11.16-10.752,16.687-16.593
				c14.524-15.339,28.797-32.737,42.402-51.702c5.945-8.297,11.766-16.886,17.429-25.746c5.005-7.805,9.874-15.809,14.597-24.001
				c4.733-8.182,9.226-16.405,13.49-24.639c4.838-9.331,9.373-18.672,13.584-27.972c9.613-21.264,17.544-42.318,23.562-62.568
				c2.288-7.711,4.305-15.308,6.029-22.758c1.975-8.485,3.563-16.781,4.765-24.837C416.36,127.164,406.309,89.882,380.217,74.815z
				M375.056,221.247c-3.96,13.26-8.798,26.906-14.451,40.761c-3.762,9.247-7.889,18.589-12.361,27.972
				c-6.468,13.594-13.657,27.261-21.504,40.845c-7.837,13.573-16.081,26.634-24.607,39.037c-5.893,8.568-11.922,16.812-18.045,24.701
				c-9.174,11.818-18.578,22.831-28.097,32.893c-5.527,5.851-11.097,11.389-16.687,16.572c-5.684,5.287-11.389,10.198-17.074,14.712
				c-16.906,13.427-33.228,22.768-47.208,27.042c-12.904,3.929-23.5,3.594-31.483-1.024c-7.983-4.608-13.584-13.615-16.624-26.76
				c-3.291-14.242-3.365-33.05-0.188-54.397c1.066-7.178,2.476-14.576,4.2-22.141c1.693-7.429,3.709-15.015,6.008-22.747
				c3.96-13.26,8.798-26.917,14.451-40.772c3.762-9.247,7.889-18.589,12.361-27.961c6.468-13.594,13.657-27.261,21.504-40.845
				c7.837-13.584,16.081-26.645,24.618-39.048c5.883-8.558,11.901-16.802,18.024-24.68c9.185-11.828,18.589-22.841,28.097-32.904
				c5.538-5.862,11.118-11.4,16.697-16.572c5.695-5.287,11.389-10.198,17.074-14.712c16.906-13.416,33.228-22.768,47.208-27.032
				c5.935-1.818,11.389-2.727,16.321-2.727c5.778,0,10.856,1.254,15.161,3.741c7.993,4.608,13.584,13.615,16.624,26.76
				c3.291,14.242,3.365,33.05,0.188,54.397c-1.066,7.178-2.476,14.576-4.211,22.141C379.371,205.928,377.354,213.514,375.056,221.247z
				"/>
				<circle style="fill:#5ADAFD;" cx="256" cy="289.98" r="46.696"/>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
				<g>
				</g>
			</svg>
		</div>
		<h1>React</h1>
		<div class="nav_wrapper">
			<div class="nav">
				<a href="#ready_to_work" data-scroll="" class="nav_link">Подготовка к работе</a>
				<a href="#preview_prolect" data-scroll="" class="nav_link">Обзор проекта</a>
				<a href="#start_app" data-scroll="" class="nav_link">Запуск приложения</a>
				<a href="#first_step" data-scroll="" class="nav_link">Первые шаги</a>
				<a href="#get_style" data-scroll="" class="nav_link">Добавление стилей</a>
				<a href="#dinamic_fuul" data-scroll="" class="nav_link">Динамическое заполнение компонента</a>
				<a href="#Prop_Types" data-scroll="" class="nav_link">Prop Types</a>
				<a href="#style" data-scroll="" class="nav_link">Стилизация</a>
				<a href="#event" data-scroll="" class="nav_link">События</a>
				<a href="#usestate" data-scroll="" class="nav_link">Хук - useState</a>
				<a href="#dinamic_style" data-scroll="" class="nav_link">Динамические CSS классы</a>
				<a href="#React_context" data-scroll="" class="nav_link">React context</a>
				<a href="#if_operator" data-scroll="" class="nav_link">Условные операторы в JSX</a>
				<a href="#work_with_form" data-scroll="" class="nav_link">Работа с формой</a>
				<a href="#custom_huck" data-scroll="" class="nav_link">Создание кастомного хука для input</a>
				<a href="#server" data-scroll="" class="nav_link">Работа с сервером</a>
				<a href="#loader" data-scroll="" class="nav_link">Создание LOADER</a>
				<a href="#react_suspense" data-scroll="" class="nav_link">React.Suspense (React.lazy)</a>
				<a href="#modal_window" data-scroll="" class="nav_link">Создание модального окна</a>
				

			</div>
		</div>
		
	</div>

	<div class="wrapper">
		<div id="ready_to_work" class="ready_to_work">
			<h2 id = 'ready_to_work'>Подготовка к работе</h2>
			<p>Для работы с <b>React</b> нам понядобится <b>Node.js</b> и пакетный менеджер <b>npm</b>. Устанавливаем <b>Node.js</b> и вместе с ним установится пакетный менеджер.</p>
			<p>Создаем папку с проектом, открываем ее и зажимая <b>Shift</b> жмем <b>ПКМ</b> по свободному полю в папке. Откроется меню и нам надо выбрать <b>Открыть окно команд</b>. Запустится коммандная строка.</p>
			<p>В коммандной строке пишем такой код:</p>
			<span class="code">npx create-react-app new-project</span>
			<p>Где <b>new-project</b> - название нашего проекта. Жмем Enter и ждем ока создастся проект. Сначала, если не установлен <b>create-react-app</b>, пакетный менеджер установит эту библиотеку, а только затем создаст проект.</p>
			<p>После того как все будет готово мы увидим лог:</p>
			<img src="images/prim1.jpg" alt="">
			<p><b>create-react-app</b> создаст минимальный комплект файлов который необходим для React приложения. Перетаскиваем эту папку с проектом Sublime Text. </p>

			<h2 id="preview_prolect">Обзор проекта</h2>
			<p>Что же там создалось?</p>
			<img src="images/prim2.jpg" alt="">
			<p>В папке <b>node_modules</b> хранятся различные библиотеки, которые служал для работы React и для различных сборщиков</p>
			<p>Файл <b>gitignore</b> служит для того что бы некоторые ненужные файлы не попадали в систему контроля версии <b>Git</b></p>
			<p>Файл <b>package.json</b> который является инструкцией для всего нашего пакета и этого приложения</p>
			<p>В папке <b>public</b> присутствуют различные файлы:</p>
			<ul>
				<li><b>favicon.ico</b> - дефолтная иконка</li>
				<li><b>manifest.json</b></li>
				<li><b>index.html</b> - тот самый файл, который запускает наше приложение, иными словами наше приложение - это одностраничник. В файл html есть div с id root, куда сы будем складывать наше приложение.</li>
			</ul>
			<p>В папке <b>src</b> так же присутствуют n-ое количество файлов</p>
			<ul>
				<li><b>index.js</b> - все наше приложение запускается из него. Здесь, если посмотреть, что происходит, то мы сначала импортируем React, затем reactDOM, далее подключаем определенные стили, потом компонент App и сервис serviceWorker. Для того что бы запустить приложение, мы обращаемся к библиотеке ReactDom и вызываем метод render, где мы рендерим компонент APP и дальше мы его складываем в div с id root, который находится в index.html</li>
				<li><b>App.js</b> - по сути это самый обычный react компонент, который создан через ключевое слово function и который возвращает определенный синтаксис. В круглых скобках мы пишем как бы html, но на самом деле это <b>JSX</b>. JSX - это такой специальный снтаксис в React, который выглядит как html, но на самом деле это просто удобные ярлыки, которые по факту работают с функциями, которые есть в React.</li>
			</ul>
			<h2 id="start_app">Запуск приложения</h2>
			<p>Для того что бы запустить приложение, открываем папку с проектом и запускаем оттуда окно комманд (Shift + ПКМ -> "Открыть окно команд")</p>
			<p>В CMD вводим команду</p>
			<span class="code">npm start</span>
			<p>Откроется браузер где будет запущено наше приложение</p>
			<h2 id="first_step">Первые шаги</h2>
			<p>Теперь для того что бы мы могли разрабатывать наше приложение внесем в базовую структуру некоторые изменения. Во-первых мы откроем файл <b>App.js</b> и и удалим там все импорты, кроме импорта React</p>
			<p>Дялее в функции <b>App()</b> удалим все что в круглых скобках после <b>return</b>. В итоге должно получиться так:</p>
			<img src="images/prim3.jpg" alt="">
			<p>Затем внутри круглых скобок добавим обыкновенный блок div.</p>
			<p>Теперь из проекта удалим файлы <b>App.css</b> и <b>logo.svg</b></p>
			<img src="images/prim4.jpg" alt="">
			<p>Теперь если посмотреть в браузере, мы увидим пустую страницу</p>
			<p>Теперь тому блоку что мы поместили в <b>App.js</b> Необходимо задать класс. Обычно в html что бы указать класс элементу, мы писали просто слово class, но в JSX мы должны указывать слово className. Зададим блоку класс - wrapper</p>
			<img src="images/prim5.jpg" alt="">
			<p>Теперь в папке <b>src</b> проекта открываем файл <b>index.css</b>. Это файл с глобальными стилями, в нем мы прописываем стили к нашему блоку wrapper</p>
			<img src="images/prim6.jpg" alt="">
			<p>Возвращаемся в <b>App.js</b></p>
			<p>В React основным принципом является компонентный подход, поэтому мы можем разрабатывать все наше приложение в отдельных компонентах и дальше их комбинировать.</p>
			<p>Как это будет выглядеть?</p>
			<p>В папке <b>src</b> мы создаем новую папку, которую называем <b>Todo</b>. В этой папке будем хранить все компоненты, которые будут относится к нашему приложению Todo (список дел - Todo-list)</p>
			<p>Например первый компонент который мы создадим будет называться <b>TodoList.js</b> (в папке Todo создаем файл с именем TodoList.js)</p>
			<p>Этот файл необходимо превратить в React компонент. Здесь для этого есть два основных правила.</p>
			<p><b>Первое</b> - мы всегда должны импортировать библиотеку React из 'react'</p>
			<img src="images/prim7.jpg" alt="">
			<p>Без этого компонент не будет работать.</p>
			<p><b>Второе</b> - мы должны что-то экспортировать наружу. Этим что-то будет являться обыкновенная функция, поэтому мы будем экспортировать по дефолту функцию TodoList (функцию называем так же как компонент) В React принято, что компоненты называются с заглавной буквы.</p>
			<img src="images/prim8.jpg" alt="">
			<p>Эта функция должна нам вернуть какой-то JSX код:</p>
			<img src="images/prim9.jpg" alt="">
			<p>Теперь для того что бы данный компонент подключился к нашему приложению, нам необходимо его добавить в компонент App.js. Для этого в файле App.js в разделе импорта добавим строчку:</p>
			<img src="images/prim10.jpg" alt="">
			<p>Теперь для того что бы данный компонент добавить в общий шаблон (весь код JSX который возвращает return называется шаблоном), мы можем функцию TodoList превратить в обыкновенный html тег, который мы помещаем внутрь div wrapper:</p>
			<img src="images/prim11.jpg" alt="">
			<h2 id="get_style">Добавление стилей</h2>
			<p>Помимо того что мы можем добавлять стили в файл <b>index.css</b>, мы так же можем их прописывать в JSX. для этого в файл <b>TodoList создадим вот такой объект:</b></p>
			<img src="images/prim12.jpg" alt="">
			<p>У объекта style есть свойство ul, которое так же является объектом. У этого объекта есть свойство listStyle со значением 'none'. Почему listStyle, а не list-style как в css? Дело в том, что в JavaScript нельзя использовать дефис в именах, поэтому используется camelCase (т.е. вместо дефиса следующее слово пишется с заглавной буквы).</p>
			<p>Теперь для того что бы стили применились в ul, в теге ul добавляем свойство style и используя фигурные скобки обращаемся к объекту style и к его свойству ul. Вообще в React фигурные скобки означают, что внутри них помещается код JavaScript</p>
			<img src="images/prim13.jpg" alt="">
			<h2 id="dinamic_fuul">Динамическое заполнение компонента</h2>
			<p>Сейчас элементы списка li заполнены статически, но что если нам надо их заполнять динамически. Для этого создадим еще один компонент <b>TodoItem</b>. В папке <b>src/Todo</b> создадим еще один файл и назовем его <b>TodoItem</b></p>
			<p>В него точно так же импортируем библиотеку React и создаем функцию, которая будет экспортироваться по дефолту:</p>
			<img src="images/prim14.jpg" alt="">
			<p>Эта функция будет возвращать JSX код</p>
			<img src="images/prim15.jpg" alt="">
			<p>Теперь возвращаемся в файл <b>TodoList</b> и правим там код. Во-первых надо импортировать компонент TodoItem</p>
			<img src="images/prim16.jpg" alt="">
			<p>Затем вместо тега li мы указываем наш новй компонент</p>
			<img src="images/prim17.jpg" alt="">
			<p>Теперь добавим динамичности нашему приложению. для этого в файле <b>App.js</b> в функции создадим массив <b>todos</b>, где каждый элемент массива будет объектом с тремя ключами:</p>
			<img src="images/prim18.jpg" alt="">
			<p>Теперь данный массива нам надо отобразить в компоненте <b>TodoList</b>. Для этого нам необходимо в компоненте <b>TodoList</b> файла App.js обозначить какие свойства мы будем принимать, для того что бы передать в него данный массив</p>
			<img src="images/prim19.jpg" alt="">
			<p>Иными словами для того что бы передать наш массив компоненту TodoList (т.е. что бы данные стали видны в файле TodoList.js) мы создали в компоненте TodoList свойство <b>todos</b> и с помощью JS передали туда наш массив</p>
			<p>Теперь переходим в файл <b>TodoList</b>. Здесь нам в функции TodoList необходимо добавить входной параметр - props. Иными словами наша функция примет некоторый props, который будет являться обьектом у которого есть ключ соответствующий значению свойства компонента, в нашем случае это массив todos</p>
			<img src="images/prim20.jpg" alt="">
			<p>Теперь в нашем шаблоне нам необходимо динамически вывести данные элементы, потому что мы не знаем сколько в массиве будет объектов.</p>
			<p>Для этого обратимся через входной параметр props к массиву todos и применем к нему метод map. На каждую итерацию цикла метод map будет возвращать объект todo (элемент массива) и дальше в callback функции мы будем возвращать компонент <b>TodoItem</b>. И в свою очередь мы компоненту TodoItem передадим свойство todo и в него поместим, то что нам вернут метод map</p>
			<img src="images/prim21.jpg" alt="">
			<p>Теперь переходим в файл <b>TodoItem</b>, в функции компонента так же добавляем входной параметр, с той только разницей что мы теперь знаем что получаем объект todo, поэтому входной параметр указываем в фигурных скобках.</p>
			<img src="images/prim22.jpg" alt="">
			<p>Т.е. мы обращаемся к объекту который нам вернул метод map</p>
			<p>Код JSX компонента <b>TodoItem</b> будет выглядеть так:</p>
			<img src="images/prim23.jpg" alt="">
			<p>Внутри тега li мы обращаем к входному параметру функции и обращаемся к полю title.</p>
			<p>Теперь если мы посмотрим в консоль, мы увидим ошибку, в которой сказано, что в React каждый итерируемый объект должен иметь уникальное свойство key. Поэтому в файле TodoList  в теле цикла компоненту TodoItem добавляем свойство key и даем ему значение {todo.id}</p>
			<img src="images/prim24.jpg" alt="">
			<p>Теперь допустим, что нам надо каждому элементу списка присваивать очередной номер и выводить его на экран, рядом с элементом списка.</p>
			<p>Для этого в файле TodoList в цикле map добавим еще один входной параметр стрелочной callback функции - index. В методе map второе значение callback функции принимает значение индекса элемента в массиве, а компоненту TodoItem зададим новое свойство index, которое нам возвращает map</p>
			<img src="images/prim25.jpg" alt="">
			<p>Теперь переходим в файл TodoItem.js и в функции добавляем новый входной параметр index</p>
			<img src="images/prim26.jpg" alt="">
			<p>А возвращаемы код JSX теперь будет выглядеть так: новый параметр index обарачиваем в тег strong, а самому значению index прибавляем - 1, т.к. отсчет элементов в массиве начинается с 0</p>
			<img src="images/prim27.jpg" alt="">
			<h2 id="Prop_Types">Prop Types</h2>
			<p>JavaScript является не типизированным языком и здесь мы можем добавлять одним и тем же переменным разные типы значений. Есть потенциальные ошибки при передаче свойств. Поэтому в реакт хорошей практикой считается описание входящих свойств в определенный компонент. Для этого нам необходимо установить дополнительную библиотеку которая называется <b>'prop-types'</b></p>
			<p>Запускаем терминал из папки с проектом (Shift + ПКМ - Открыть окно команд) и вводим такую строку</p>
			<span class="code">npm install prop-types</span>
			<p>После того как установка завершится нам необходимо перезапустить наш проект.</p>
			<span class="code">npm start</span>
			<p>Теперь мы можем пользоваться библиотекой prop-types для того что бы определять входящие свойства. Начнем с компонента TodoList. Переходим в него.</p>
			<p>Мы знаем что в данный компонент мы принимаем параметр <b>todos</b>, поэтому нам необходимо его валидировать (т.е. указать какой тип данных должен иметь этот параметр, в нашем случае это массив).</p>
			<p>Для начала в разделе импорта пропишем библиотеку <b>prop-types</b></p>
			<img src="images/prim28.jpg" alt="">
			<p>Теперь для того что бы добавить валидацию свойству, немного изменим код нашей функции шаблона. Убираем у нее операторы экспорта по дефолту, после чего в самом конце файла добавляем строку - <b>export default TodoList</b>. иными словами мы экспортируем нашу функцию не сразу при инициализации и после. Вот как это стало выглядеть:</p>
			<img src="images/prim29.jpg" alt="">
			<p>Теперь перед экспортом мы обращаемся к нашей функции <b>TodoList</b>, создаем у нее новое свойство <b>propTypes</b>. В это свойство мы помещаем объект, где мы будем описывать типы данных свойств. В качестве ключа будет название свойства, а в качеестве значения ключа будет тип данных. Что бы задать тип данных мы будем обращаться к библиотеке PropTypes и вызывать у нее метод соответствующий типу данных свойства:</p>
			<img src="images/prim30.jpg" alt="">
			<p>С помощью PropTypes можно устанавливать более сложную валидацию. К примеру мы знаем что наш массив todos должен состоять из объектов (обращаем внимание на то, что теперь не просто array, а arrayOf). Так же мы добавляем метод <b>isRequired</b> - который говорит о том, что это свойство обязательно. Выглядеть это будет так:</p>
			<img src="images/prim31.jpg" alt="">
			<p>Вот как на данном этапе выглядит наш файл TodoList</p>
			<img src="images/prim32.jpg" alt="">
			<p>Теперь добавим валидацию для компонента <b>TodoItem</b>. Здесь мы получаем два параметра (todo и index). Точно так же убираем у функции шаблона export default и в конце файла добавляем сточку</p>
			<img src="images/prim33.jpg" alt="">
			<p>Не забываем импортировать библиотеку PropTypes, а перед export создаем новый ключ PropTypes для нашей функции:</p>
			<img src="images/prim34.jpg" alt="">
			<h2 id="style">Стилизация</h2>
			<p>Теперь поработаем над шаблоном каждого элемента li и превратим его во что-то более красиваое. Переходим в компонент <b>TodoItem</b> и меняем структуру JSX</p>
			<img src="images/prim35.jpg" alt="">
			<p>Мы добавили input с типом checkbox, кнопку в которую поместили символ html (крестик). Теперь добавим немного стилей. Создадим объект style который будет в себе содержать стили для всех элементов</p>
			<img src="images/prim36.jpg" alt="">
			<p>Теперь что бы стили применились, создадим у элементов свойство style и с помощью JS обратимся в нашему объекту, так же между индексом и title добавим html сивол пробела</p>
			<img src="images/prim37.jpg" alt="">
			<h2 id="event">События</h2>
			<p>Теперь нам необходимо сделать так, что бы при нажатии на checkbox надпись зачеркивалась</p>
			<p>Для этого нам надо работать через корневой компонент App.js. Массив todos на самом деле является определенным стейтом (state) и мы не можем изменять отдельный компонент где-то в дочерних элементах. Если мы что-то меняем, нам необходимо изменять сам стейт. Поэтому задача звучит так: при нажатии на checkbox мы должны по тому элементу, по которому мы кликнули изменить у него флаг completed на противоположное значение. И только после этого перерисовывать все дочерние элементы т.е. TodoList и TodoItem.</p>
			<p>Для начала разберемся как мы вообще добавляем определенные события для элементов в JSX</p>
			<p>Мы добавляем новый атрибут для input, например это может быть атрибут <b>onChange</b>, дальше в качестве значения мы указываем фигурные скобки (т.е. внутри будет JS)? куда мы должны передать callBack который должен будет выполнен.</p>
			<p>onChange название не произвольное, это реальный атрибут тега, как в HTML.</p>
			<p>Рассмотрим такой код:</p>
			<img src="images/prim38.jpg" alt="">
			<p>callback функция выводит в консоль id элемента по которому кликнули. Теперь нам надо передать данное событие в родительский элемент. Для этого мы можем принимать в компоненте TodoItem еще один параметр. Это будет событие onChange</p>
			<img src="images/prim39.jpg" alt="">
			<p>И все что мы будем делать когда будет происходить событие onChange input - мы будем вызывать событие onChange - то самое которое является входным параметром у функции TodoItem и передавать в него todo.id.</p>
			<img src="images/prim40.jpg" alt="">
			<p>Далее опишем новый входной параметр функции TodoItem - onChange в PropTypes</p>
			<img src="images/prim41.jpg" alt="">
			<p>Теперь мы знаем, что в компонент TodoItem мы передали функцию onChange. TodoItem у нас выводится в списке компонента TodoList, поэтому для каждого Todo элемента нам надо передать свойство onChange. Но данное событие нам необходимо соединить с родительским элементом App.js, поэтому в это свойство мы будем передавать объект props с методом onToggle (название метода произвольное, позднее в компоненто App.js мы его опишем). Итак переходим в компонент TodoList и правим там код:</p>
			<img src="images/prim42.jpg" alt="">
			<p>Теперь так же в TodoList опишем в PropTypes новый метод onToggle</p>
			<img src="images/prim43.jpg" alt="">
			<p>Теперь переходим в файл App.js и в шаблоне компоненту TodoList добавляем новое свойство <b>onToggle</b> и передаем ему метод который назовем toggleTodo (название так же произвольное)</p>
			<img src="images/prim44.jpg" alt="">
			<p>Данный метод надо определить в компоненте App.js. Это будет самая обыкновенная функция, которая будет принимать в себя <b>id</b> и для проверки выведем этот id в консоль</p>
			<img src="images/prim45.jpg" alt="">
			<p>Теперь зная id	мы можем изменять state (массив объектов todos). Для этого мы обращаемся к массиву и применяем метод map, т.е переопределяем массив. Метод map возвращает callback который принимает объект todo (элемент массива на каждой итерации) и мы проверяем, если id элемента равен id (входному параметру функции toggleTodo) то мы меняем значение ключа completed на противоположный, затем мы возвращаем todo</p>	
			<img src="images/prim46.jpg" alt="">
			<h2 id="usestate">Хук - useState</h2>
			<p>Добавим в компонент TodoItem (в функцию) перед return строку:</p>
			<img src="images/prim47.jpg" alt="">
			<p>Эта строчка должна перерендрится и вызываться каждый раз когда мы изменяем флаг checkbox. Но этого не происходит. Почему?</p>
			<p>Таким образом как мы задали state (наш массив) в React мы задавать не можем. Для того что бы определить state, за которым будет следить React и для того что бы перерендрировать наш шаблон и добавлять динамики приложению, мы должны определять state иначе. Мы не можем просто так завести переменную, на мнужно воспользоваться специальной функцией в React которая называется <b>useState</b>.</p>
			<p><b>useState</b> - это хук. Здесь идея заключается в том, что мы создаем некоторую переменную, например назовем ее <b>q</b>, которая будет результатом работы React и его функции useState</p>
			<img src="images/prim48.jpg" alt="">
			<p>В функцию useState мы передаем некоторое начальное состояние, которое мы хотим задать для данного state-a, т.е в нашем случае это будет наш массив с объектами</p>
			<img src="images/prim49.jpg" alt="">
			<p>Как теперь нам получить state и что вообще возвращает функция useState?</p>
			<p>Функция useState нам возвращает массив состоящий ВСЕГДА из двух элементов. Первый элемент - это непосредственно само состояние, т.е оно будет равно дефолтному состоянию state. Второй элемент - это функция позволяющая изменять данное состояние state при том что React будет фиксировать эти изменения и на них реагировать. Для того что бы было комфортно с этим работать мы можем избавится от переменной q и записать код с использованием диструктуризации:</p>
			<img src="images/prim50.jpg" alt="">
			<p>setTodos - это функция, которая нам позволит изменять state (по конвенции имя метода позволяющего изменять state должно начинаться с set)</p>
			<p>Теперь в функции toggleTodo мы можем воспользоваться методом setTodos. Для этого просто вызовем этот метод и на фход дадим ему результат метода map</p>
			<img src="images/prim51.jpg" alt="">
			<p>Теперь при нажатии на checkBox в консоль выводится весь наш массив, т.е консоль-лог который мы прописали в TodoItem рендрится, React отслеживает изменение state</p>
			<h2 id="dinamic_style">Динамические CSS классы</h2>
			<p>Теперь необходимо отобразить то, что мы выполнили todo (дело в списке) т.е. поставив checkbox в значение true - надпись должна зачеркнуться.</p>
			<p>Для этого мы добавим дополнительный класс в index.css</p>
			<img src="images/prim52.jpg" alt="">
			<p>Далее нам этот класс необходимо добавлять в компонент TodoItem в зависимости от пола completed (если false то класса done нет, если true - то класс done добавляется.)</p>
			<p>В функции <b>TodoItem</b> перед return мы заводим переменную <b>classes</b>, которая по умолчанию будет пустым массивом:</p>
			<img src="images/prim53.jpg" alt="">
			<p>Дальше мы спрашиваем: если todo.completed находится в значении true, то тогда массиву clases мы пушим класс done</p>
			<img src="images/prim54.jpg" alt="">
			<p>Теперь данный массив нам необходимо передать в шаблон в качестве значения свойства <b>className</b> для тега span</p>
			<img src="images/prim55.jpg" alt="">
			<p>Метод <b>join</b> объединяет все элементы массива в строку и между ними добавляет то что мы передали в качестве входного параметра, в нашем случае это просто пробел.</p>
			<p>Теперь на что обращаем внимание. Если изначально в массиве у одного из объектов ключ completed изначально в значении true, то мы увидим что текст перечеркнут, но галочка checkbox не будет отмечена</p>
			<img src="images/prim56.jpg" alt="">
			<p>Для исправления мы в JSX тегу input добавляем свойство <b>checked</b> и в качестве значения ему передаем todo.completed</p>
			<img src="images/prim57.jpg" alt="">
			<p>Теперь все отображается корректно</p>
			<h2 id="React_context">React context</h2>
			<p>Теперь поработаем над кнопкой для удаления каждого из todo. По нажатию кнопки должно происходить удаление объекта из массива и из шаблона.</p>
			<p>Для этого разберем следующий концепт. В первом примере с onChange мы разобрали как поэтапно можно передавать функции от дочернего элемента к родительскому. И для этого нам пришлось вначале передать onChange для компонента TodoList, после нам пришлось передать свойство onToggle в компонент App и представим если вложенность была бы больше, тогда бы у нас было бы много больше кода.</p>
			<p>Поэтому в React есть очень крутая фича, которая позволяет на прямую передавать определенные свойства, избегая некоторых промежуточных этапов.</p>
			<p>Для этого в папке <b>src</b> мы создадим новый файл, который назовем context.js (название компонента произвольное). Далее внутри этого файла мы создадим определенный контекст, который впоследствии мы будем использовать</p>
			<p>Первое чтонадо сделать, это прописать импорт главной библиотеки React</p>
			<img src="images/prim58.jpg" alt="">
			<p>Далее создадим переменную с произвольным именем (в примере мы назовем ее <b>Context</b>.</p>
			<img src="images/prim59.jpg" alt="">
			<p>Эту переменную мы получили в результате вызова метода <b>createContext</b> глобальной библиотеки React</p>
			<p>Далее мы экспортируем по дефолту данный контекст</p>
			<img src="images/prim60.jpg" alt="">
			<p>Теперь мы можем его использовать. В компоненте App мы теперь его должны импортировать:</p>
			<img src="images/prim61.jpg" alt="">
			<p>Дальше нам нужно сделать следующее с компонентом: Context - это не самый обычный объект в React. Для того что бы нам передавать определенные функции сквозь другие компоненты, нам необходимо обернуть весь шаблон в специальный компонент, который называется <b>Context.Provider</b>. Весь JSX в файле App.js оборачиваем в этот тег</p>
			<img src="images/prim62.jpg" alt="">
			<p>B дальше тегу <b>Context.Provider</b> как свойство мы можем здесь указать свойство <b>value</b>, которое принимает в себя объект</p>
			<img src="images/prim63.jpg" alt="">
			<p>Первые фигурные скобки говорят о том, что будет использоваться JS, вторые - о том что это объект.</p>
			<p>Внутрь объекта мы передаем что угодно. Но нам надо реализовать функционал по удалению todo, поэтому в App.js мы создадим функцию, которая будет принимать в себя id того todo которого надо удалить.</p>
			<img src="images/prim64.jpg" alt="">
			<p>Мы вызываем метод <b>setTodos</b> и на вход ему даем массив, который нам вернет метод <b>filter</b>, который  мы применили к массиву <b>todos</b> (напомню что метод filter возвращает массив только с теми значениями которые соответствуют условию которое указано в callback функции метода filter. В нашем случае filter вернет только те значения id которых будут не равны id которое мы передадим функции <b>removeTodo</b>)</p>
			<p>Теперь мы эту функцию можем передать в качестве значения value Context.Provider</p>
			<img src="images/prim65.jpg" alt="">
			<p>Так как ключ и значения объекта совпадают, эта же запись может выглядеть вот так:</p>
			<img src="images/prim66.jpg" alt="">
			<p>Итак с помощью контекста мы передали функцию removeTodo, далее в компоненте TodoItem нам необходимо его как-то получить. Для этого вначале необходимо импортировать тот же самый Context (в разделе импорта файла TodoItem прописываем новый import)</p>
			<img src="images/prim67.jpg" alt="">
			<p>Теперь в React используем еще один хук - <b>useContext</b>. Для этого сначала отредактируем строчку с импортом React в файлу TodoItem</p>
			<img src="images/prim68.jpg" alt="">
			<p>Далее нам необходимо воспользоваться этой функцией в функции <b>TodoItem</b>. Мы создадим объект и в качестве значения мы вызовем функцию useContext куда просто передадим Context который подключали.</p>
			<img src="images/prim69.jpg" alt="">
			<p>В <b>const {}</b> - мы получаем объект, который совпадает с тем значением value, которое мы передали в Context.Provider. Учитывая то, что у данного объекта есть ключ removeTodo, то мы так же в компоненте можем получить это значение. В итогде это будет выглядеть так:</p>
			<img src="images/prim70.jpg" alt="">
			<p>Теперь на кнопке button мы создадим свойство <b>onClick</b> и передадим ему в качестве значения callBack который будет вызывать функцию removeTodo с входным параметром todo.id</p>
			<img src="images/prim71.jpg" alt="">
			<p>Почему нельзя сразу вызвать функцию removeTodo без callback? Потому что в этом случае функция будет вызвана сразу и при загрузке страницы все todo будут удалены.</p>
			<p>Есть правда второй вариант как нам прописать функцию removeTodo без моментального вызова функции. Это с помощью метода <b>bind</b></p>
			<img src="images/prim72.jpg" alt="">
			<h2 id="if_operator">Условные операторы в JSX</h2>
			<p>Теперь если мы удалим все todo, то у нас будет пустое окно. Сделаем так, что если у нас нет никаких todo, то на экране будет отображаться текст: "No todos"</p>
			<p>Там где мы выводим TodoList (в файле App.js) надо добавить условие. Для того что бы обратиться к JavaScript внутри шаблона указываем фигурные скобки и дальше спрашиваем: если в массиве todos поле length отлично от нуля, то тогда мы будем выводить наш компонент TodoList. Иначе - мы будем выводить тег p (параграф) с текстом "No todos"</p>
			<img src="images/prim73.jpg" alt="">
			<h2 id="work_with_form">Работа с формой</h2>
			<p>Теперь добавим форму, которая позволит нам добавлять новый todo элемент в список дел.</p>
			<p>Для этого создадим новый компонент, назовем его AddTodo.js</p>
			<p>Как обычно импортируем в него глобальную библиотеку React, создаем функцию которая будет возвращать шаблон, а так же не забываем экспортировать нашу функцию по дефолту:</p>
			<img src="images/prim74.jpg" alt="">
			<p>Теперь опишем шаблон. Здесь мы будем возвращать тег form внутри которого будет поле input и кнопка button с типом submit</p>
			<img src="images/prim75.jpg" alt="">
			<p>Теперь переходим в файл App.js где в первую очередь нам необходимо импортировать наш новый компонент:</p>
			<img src="images/prim76.jpg" alt="">
			<p>А в шаблоне сразу после заголовка h1 добавляем тег AddTodo</p>
			<img src="images/prim77.jpg" alt="">
			<p>Добавим стилей нашей форме:</p>
			<img src="images/prim78.jpg" alt="">
			<p>Дальше нам необходимо обработать наш input, потому что пока, если мы будем вписывать в него наш todo и нажимать Add todo то ничего не произойдет.</p>
			<p>Здесь мы так же выспользуемся хуков useState в файле AddTodo</p>
			<img src="images/prim79.jpg" alt="">
			<p>В функции AddTodo создадим переменные с помощью диструктуризации: value и setValue и начальное состояние этих переменных будет пуская строка. Напомню, хук useState всегда возвращает массив из двух элементов (состояние state и функция при помощи которой происходит изменение state)</p>
			<img src="images/prim80.jpg" alt="">
			<p>Теперь необходимо привязать эти две переменные к input</p>
			<img src="images/prim81.jpg" alt="">
			<p>У input мы создаем два свойства value и onChange. value мы присваиваем значение переменной value, а свойству onChange мы присвоили callback функцию, которая принимает в себя параметр event и которая мызывает метод setValue (для изменения state) на вход которой мы даем параметр со значением элемента в таргете.</p>
			<p>Далее добавим обработчик события на <b>форму</b> (т.е. в теге form, не на кнопке). Событие называется onSubmit и здесь мы будем вызывать метод который назовем submitHandler (название произвольное)</p>
			<img src="images/prim82.jpg" alt="">
			<p>Теперь создадим этот метод. По умолчанию эта функция принимает значение event, у которого отменяем дефолтное поведение (это для того что бы при нажатии на submit страница не перезагружалась). Затем добавим небольшую валидацию. Если у нас input пустой тогда ничего не делаем:</p>
			<img src="images/prim83.jpg" alt="">
			<p>Если значение value - пусто (метод trim удаляет пробелы. Пустое значение возвращает 0 или false, а значит value - если пустое, то вернет false, если что то там есть то вернет true) то мы вызываем метод create</p>
			<p>Что за метод Create? мы его пока не создали, но укажем его входящим параметром функции AddTodo</p>
			<img src="images/prim84.jpg" alt="">
			Сразу же пропишем тип этого входного параметра. Для этого импортируем библиотеку PropTypes
			<img src="images/prim85.jpg" alt="">
			<p>Теперь перед export обратимся к AddTodo и добавим ему ключ propTypes куда поместим тип данных входного параметра:</p>
			<img src="images/prim86.jpg" alt="">
			<p>Теперь в компоненте App.js нам необходимо передать данный метод компоненту AddTodo в качестве свойства, а в значение свойства поместить функцию addTodo</p>
			<img src="images/prim87.jpg" alt="">
			<p>Теперь создадим функцию <b>addTodo</b>. Эта функция будет принимать некоторый title. И что мы тут делаем? Мы вызываем state методом setTodos, на вход даем ему массив todos, к массиву применяем метод <b>concat</b>. Этот метод возвращает нам новый массив состоящий из соединения старого массива с новым, который мы передадим входным параметром методу. В качестве входного параметра методу concat мы передадим объект, который будет присоединен к уже имеющему массиву.</p>
			<p>У этого объекта будет поле title, которое будет совпадать со значением title (входной параметр функции и куда мы передадим значение input формы). Так же будет id со значением Date.now() (этот метод возвращает количество милисекунд прошедших с 1 января 2000 года. т.е  это значение в любой момент уникальное. Для ID самый раз), а так же поле completed со значением false</p>
			<img src="images/prim88.jpg" alt="">
			<p>Теперь если ввести в input какой либо текст и кликнуть по Add todo (или нажать Enter) то в список добавится новый todo</p>
			<p>Теперь сделаем так, что бы при добавлении нового todo поле input очищалось. Для этого в компоненте AddTodo после того как мы вызвыали метод onCreate мы вызываем метод setValue и даем ему значение пустой строки:</p>
			<img src="images/prim89.jpg" alt="">
			<h2 id="custom_huck">Создание кастомного хука для input</h2>
			<p>Сейчас мы пользуемся стандартным хуком <b>useState</b>, но на самом деле мы можем создавать свои собственные хуки и улучшать наше приложение.</p>
			<p>Допустим мы знаем что в компоненте input в обычный html тег мы передаем всегда два свойства для того что бы он работал (value и onChange). По сути мы можем это дело немного упростить.</p>
			<p>Создадим хук (функцию) и по конвенции мы должны его называть начиная словом use и дальше с большой буквы (например useInputValue)</p>
			<p>Эта функция будет принимать параметр defaultValue и это будет пустая строка. Открываем файл addTodo.js и добавляем строчку</p>
			<img src="images/prim90.jpg" alt="">
			<p>Что мы делаем дальше? Мы выносим в нашу функцию логику по определению этого value. С помощью хука useState т.е. мы внутри нашей функции создаем две переменные value и setValue</p>
			<img src="images/prim91.jpg" alt="">
			<p>Теперь эта функция в качестве значения будет возвращать объект у которого будет поле value, которое будет равняться значению valueb будет значение onChange и это будет функция, которая принимает event и она будет обращаться к setValue и задавать ему значение event.target.value</p>
			<img src="images/prim92.jpg" alt="">
			<p>Т.е. функция возвращает те значения которые нужны для input </p>
			<p>Теперь как нам это может помочь? В компоненте AddTodo мы можем создать переменную input и воспользоваться хуком useInputValue</p>
			<img src="images/prim93.jpg" alt="">
			<p>По умолчанию мы передаем пустую строчку. Теперь для того что бы обработать этот input мы можем удалить свойства value и onChange у тега input в JSX и обратиться к фигурным скобкам с помощью оператора spread разворачиваем наш объект который мы поместили в переменную input с помощью функции useInput</p>
			<img src="images/prim94.jpg" alt="">
			<p>Теперь в функции submitHandler немного поправим код. Переменной value у нас больше нет, но есть объект input с ключом value, поэтому функция теперь будет выглядеть так:</p>
			<img src="images/prim95.jpg" alt="">
			<p>Функция setValue('') с пустым входным параметром нам теперь не доступна и как нам теперь очистить поле input после вызова onCreate?</p>
			<p>Для этого есть разные способы. Рассмотрим один из них.</p>
			<p>В хуке useInputValue заведем новый объект который назовем bind и в него передадим все ключи value и setValue</p>
			<p>Далее мы определим функцию, например clear, которая будет обращаться к функции setValue с пустой строкой. Создадим функцию value с помощью которой мы будем получать значение value</p>
			<img src="images/prim96.jpg" alt="">
			<p>Теперь немного изменим код в теге input. Что бы правильно добавлялись поля, оператора spread мы применяем к input.bind</p>
			<img src="images/prim97.jpg" alt="">
			<p>В методе submitHandler что бы получить значение, мы обращаемся к функции value(), а для того что бы очистить поле input мы обращаемся к объекту input и	вызываем метод clear()</p>
			<img src="images/prim98.jpg" alt="">
			<h2 id="server">Работа с сервером</h2>
			<p>Теперь разберемся, как данное приложение может работать с сервером</p>
			<p>Для примера обратимся к серверу JSONPlaceholder, где мы можем получитьтакой же список todos какой мы используем в примере</p>
			<p>Заходим на сайт <a href="http://jsonplaceholder.typicode.com/">http://jsonplaceholder.typicode.com/</a> и с главной страницы копируем код примера</p>
			<img src="images/prim99.jpg" alt="">
			<p>Теперь нам необходимо в компоненте App.js сделать запрос на сервер с помощью метода <b>fetch</b></p>
			<p>Запрос надо сделать когда будет готово DOM дерево и для того что бы отследить этот момент в функциональных компонентах мы можем пользоваться новым хуком в REACT который называется useEffect</p>
			<img src="images/prim100.jpg" alt="">
			<p>Теперь, допустим, тогда когда у нас стартует приложение, после того как мы определили state мы можем вызвать useEffect (т.е. вызываем его после let[todos, setTodos]...) В данную функцию мы передадим callback функцию, которая будет выполнена и вторым параметром для того что бы сделать запрос мы передадим пустой массив. Этот пустой массив будет являться списком зависимостей, которые будут служить для того что бы отрабатывать данному callback. Но так как нам этот callback надо отработать только один раз, массив этот будет пустым. Вот как выглядит useEffect на данном этапе</p>
			<img src="images/prim101.jpg" alt="">
			<p>Теперь в callback функции скопируем текст который мы взяли с сайта JSONplaceholde. </p>
			<p>Что тут происходит? Здесь мы обратились к методу fetch. С адреса мы получили список todos. Саму ссылку мы отредактировали, что бы получить не 100 todo, а только 5 </p>
			<p><b>https://jsonplaceholder.typicode.com/todos?_limit=5</b></p>
			<p>Далее во втором then мы получаем массив todos и здесь для того что бы изменить state мы обращаемся к функции setTodos и в него передаем массив todos</p>
			<p>Вот как useEffect выглядит теперь</p>
			<img src="images/prim102.jpg" alt="">
			<p>Теперь если открыть наше приложение и обновить страницу, то можно заметить, что сначала загрузились наши старые значения, а через мгновения вместо них появились значения из массива</p>
			<p>Т.е. теперь в state как дефолтное значение мы можем указать пустой массив</p>
			<img src="images/prim103.jpg" alt="">
			<h2 id="loader">Создание LOADER</h2>
			<p>Учитывая то, что у нас идет работа с сервером, а JSONPlaceholder отвечает быстро, мы сможем сэмулировать задержку сервера, для того что бы разобраться со следующей задачей (созданием loader)</p>
			<p>Для этого во втором then мы все обернем в setTimeout и поставим задержку в 2 секунды</p>
			<img src="images/prim104.jpg" alt="">
			<p>Теперь наши todo подгружаются с задержкой в 2 секунды, нам необходимо добавлять определенный loader</p>
			<p>Заходим на сайт <a href="https://loading.io/css">https://loading.io/css</a></p>
			<p>Здесь можно скопировать CSS код для loader</p>
			<p>В папке src проекта создаем новый компонент, назовем его <b>Loader.js</b>. Это обычный react компонент, поэтому прописываем в нем стандартные строки.</p>
			<p>Здесь мы можем экспортировать по дефолту стрелочную функцию которая возвращает JSX код с блоком div</p>
			<img src="images/prim105.jpg" alt="">
			<p>Внутрь этого блока div копируем html код лоадера который мы скопировали с сайта (не забываем переименовать class в className)</p>
			<img src="images/prim106.jpg" alt="">
			<p>Теперь с сайта loading.io копируем CSS стили и добавляем их в файл index.css</p>
			<p>Теперь для div который явялется оберткой для нашего loader добавим немного стилей</p>
			<img src="images/prim107.jpg" alt="">
			<p>Теперь в файле App.js надо импортировать наш файл Loader.js</p>
			<img src="images/prim108.jpg" alt="">
			<p>И дальше нам надо показывать его в том случае если у нас идет процесс загрузки. Для этого мы заведем новый state (новую переменную) для того что бы следить за loading</p>
			<img src="images/prim109.jpg" alt="">
			<p>Функции useState мы изначально передадим значение true т.к. изначально страница должна отобразится с loader</p>
			<p>Далее в шаблоне App.js (в JSX) после того как мы определяем компонент AddTodo мы будем спрашивать: если переменная loading находится в значении true, тогда мы показываем компонент loader</p>
			<img src="images/prim110.jpg" alt="">
			<p>Теперь если мы посмотрим на результат, то мы не увидим наш loader т.к. у него в стилях указан белый цвет, поменяем его на синий</p>
			<img src="images/prim111.jpg" alt="">
			<p>Теперь сделаем так что бы loader пропадал как только загрузка закончится. Для этого во-первых там где мы выводим текс no todos мы можем добавить условие через тернарный оператор</p>
			<img src="images/prim112.jpg" alt="">
			<p>Если loading = true то ничего не возвращаем, иначе возвращаем тег p </p>
			<p>Теперь, когда у нас закончилась загрузка нам надо убирать loader. Делается это очень просто. После того как мы сделаем setTodos мы возвращаем метод setLoading(false)</p>
			<img src="images/prim113.jpg" alt="">
			<h2 id="react_suspense">React.Suspense (React.lazy)</h2>
			<p>Допустим, что мы посмотрели на наш компонент AddTodo и решили что что он у нас слишком объемный, из за этого нам необходимо загружать его отдельно от основного окна. Как нам это сделать.</p>
			<p>Для начала в файле App.js удалим import компонента AddTodo. Потому что если мы его оставим то этот Todo будет добавлен в финальный bandle (с англ. - Пучок)</p>
			<p>Для того что бы его загрузить лениво (lazy load) мы создадим переменную AddTodo и дальше мы обратимся к библиотеке React и вызовем метод <b>lazy</b></p>
			<img src="images/prim114.jpg" alt="">
			<p>Методу lazy мы передадим callback функцию, где мы обратимся к динамическому импорту и укажем путь до нужного компонента:</p>
			<img src="images/prim115.jpg" alt="">
			<p>Теперь у нас есть переменная AddTodo, которая динамически подгружает нам нужный компонент. но для того что бы React понял что мы загружаем его лениво, здесь необходимо воспользоваться специальным компонентом в React который называется <b>React.Suspense</b>. После заголовка h1 добавим его, а внутрь передаем AddTodo</p>
			<img src="images/prim116.jpg" alt="">
			<p>Сейчас если посмотреть на приложение в браузере, мы получим ошибку, где написано, что нам не хватает параметра <b>fallback</b></p>
			<p>Добавим его для компонента Suspense. В качестве fallback мы должны передать какое-то значение, что будет показываться пока этот компонент будет грузиться. Например параграф с текстом loading...</p>
			<img src="images/prim117.jpg" alt="">
			<p>Если мы оставим все в таком виде, то мы не увидим существенных изменений, компонент загрузится слишком быстро. Для наглядности добавим задержку. Для этого преобразуем метод import у React.lazy</p>
			<img src="images/prim118.jpg" alt="">
			<h2 id="modal_window">Создание модального окна</h2>
			<p>Теперь рассмотрим как работают классический react компоненты, которые преобразованы от класса. Для этого на придется создать новый компонент и для него создадим в корне папки src папку Modal. В ней создадим файл Modal.css и Modal.js</p>
			<p>В файле CSS пропишем стили:</p>	
			<img src="images/prim119.jpg" alt="">
			<p>Теперь заходим в файл Modal.js</p>
			<p>Импортируем React и стили</p>
			<img src="images/prim120.jpg" alt="">
			<p>Теперь для того что бы сформировать компонент от React компонента здесь мы сразу экспортируем по default класс modal и он должен наследоваться от React.component</p>
			<img src="images/prim121.jpg" alt="">
			<p>Теперь для того что бы здесь формировать шаблон, мы должны реализовать метод render и в state-е return мы возвращаем какой-то код:</p>
			<img src="images/prim122.jpg" alt="">
			<p>Здесь у нас будет два корневых элемента и для того что бы react не добавлял никакого корневого элемента, мы можем воспользоваться компонентом <b>React.Fragment</b></p>
			<img src="images/prim123.jpg" alt="">
			<p>Теперь внутри React.Fragment мы можем описать два компонента (вообще что хотим описываем). Допустим это будет кнопка button и шаблон который относится к модалке:</p>
			<img src="images/prim124.jpg" alt="">
			<p>Теперь подключим этот компонент в главном компоненте App.js. Для этого сначала импортируем компонент</p>
			<img src="images/prim125.jpg" alt="">
			<p>Затем в шаблоне после тега h1 добавляем наш компонент modal</p>
			<img src="images/prim126.jpg" alt="">
			<p>Теперь если посмотреть на приложение, то поверх всего у нас торчит модальное окно.</p>
			<p>Нам надо сделать так, что бы это модальное окно появлялось только после нажатия на кнопку</p>
			<p>В компоненте Modal.js мы заводим state, но в этот раз мы уже не будем пользоваться хуками, мы будем пользоваться классическим state в React. Для этого определяем поле state перед render</p>
			<img src="images/prim127.jpg" alt="">
			<p>Это объект и по умолчанию у него будет поле <b>isOpen</b> равное false</p>
			<img src="images/prim128.jpg" alt="">
			<p>Далее если state у нас находится в значении false, то тогда мы не должны показывать этот шаблон</p>
			<p>Поэтому весь код с модальным окном (кроме кнопки открытия модалки) оборачиваем в фигурные скобки и добавляем условие: если у этого элемента state.isOpen = true тогда отображаем модалку</p>
			<img src="images/prim129.jpg" alt="">
			<p>Теперь при клике на кнопку Open Modal мы должны создать OnClick и в него передать callback. Здесь мы обращаемся к полю this и вызвать метод который называется setState, в котором мы должны указать новое значение флагу isOpen - true</p>
			<img src="images/prim130.jpg" alt="">

			<p>Теперь для закрытия модалки, кнопке Close Modal так же создаем свойство onClick</p>
			<img src="images/prim131.jpg" alt="">




	




			

	








		</div>



	



	</div>
	<script src="js/jquery.js"></script>
	<script src="js/script.js"></script>
</body>
</html>